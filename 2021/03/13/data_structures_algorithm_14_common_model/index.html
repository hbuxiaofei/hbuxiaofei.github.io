<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="CLGwJbU8jWqDUNV65d7JW65vqOgp2zSwbfCCVjhZcXo">
  <meta name="baidu-site-verification" content="code-NqxVcgKLLc">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.rayylee.xyz","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="下面列出最常见的 14 种算法模式，它们可被用于解决常见的问题。另外还会说明如何识别每种模式，并会为每种模式提供一些问题示例。1．滑动窗口2．二指针或迭代器3．快速和慢速指针4．合并区间5．循环排序6．原地反转链表7．树的宽度优先搜索（Tree BFS）8．树的深度优先搜索（Tree DFS）9．Two Heaps10．子集11．经过修改的二叉搜索12．前 K 个元素13．K 路合并14．拓扑排序">
<meta property="og:type" content="article">
<meta property="og:title" content="14种常用算法模式">
<meta property="og:url" content="https://www.rayylee.xyz/2021/03/13/data_structures_algorithm_14_common_model/index.html">
<meta property="og:site_name" content="Rayy Lee">
<meta property="og:description" content="下面列出最常见的 14 种算法模式，它们可被用于解决常见的问题。另外还会说明如何识别每种模式，并会为每种模式提供一些问题示例。1．滑动窗口2．二指针或迭代器3．快速和慢速指针4．合并区间5．循环排序6．原地反转链表7．树的宽度优先搜索（Tree BFS）8．树的深度优先搜索（Tree DFS）9．Two Heaps10．子集11．经过修改的二叉搜索12．前 K 个元素13．K 路合并14．拓扑排序">
<meta property="og:locale">
<meta property="article:published_time" content="2021-03-13T13:53:12.000Z">
<meta property="article:modified_time" content="2022-01-26T11:32:36.988Z">
<meta property="article:author" content="Rayy Lee">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.rayylee.xyz/2021/03/13/data_structures_algorithm_14_common_model/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>14种常用算法模式 | Rayy Lee</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rayy Lee</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-book">

    <a href="/book/" rel="section"><i class="fa fa-book fa-fw"></i>书籍</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.rayylee.xyz/2021/03/13/data_structures_algorithm_14_common_model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Rayy Lee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rayy Lee">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          14种常用算法模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-13 21:53:12" itemprop="dateCreated datePublished" datetime="2021-03-13T21:53:12+08:00">2021-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-26 19:32:36" itemprop="dateModified" datetime="2022-01-26T19:32:36+08:00">2022-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/13/data_structures_algorithm_14_common_model/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/13/data_structures_algorithm_14_common_model/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>下面列出最常见的 14 种算法模式，它们可被用于解决常见的问题。另外还会说明如何识别每种模式，并会为每种模式提供一些问题示例。<br><a href="#1%EF%BC%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">1．滑动窗口</a><br><a href="#2%EF%BC%8E%E4%BA%8C%E6%8C%87%E9%92%88%E6%88%96%E8%BF%AD%E4%BB%A3%E5%99%A8">2．二指针或迭代器</a><br><a href="#3%EF%BC%8E%E5%BF%AB%E9%80%9F%E5%92%8C%E6%85%A2%E9%80%9F%E6%8C%87%E9%92%88">3．快速和慢速指针</a><br><a href="#4%EF%BC%8E%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4">4．合并区间</a><br><a href="#5%EF%BC%8E%E5%BE%AA%E7%8E%AF%E6%8E%92%E5%BA%8F">5．循环排序</a><br><a href="#6%EF%BC%8E%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">6．原地反转链表</a><br><a href="#7%EF%BC%8E%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">7．树的宽度优先搜索（Tree BFS）</a><br><a href="#8%EF%BC%8E%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">8．树的深度优先搜索（Tree DFS）</a><br><a href="#9%EF%BC%8ETwoHeaps">9．Two Heaps</a><br><a href="#10%EF%BC%8E%E5%AD%90%E9%9B%86">10．子集</a><br><a href="#11%EF%BC%8E%E7%BB%8F%E8%BF%87%E4%BF%AE%E6%94%B9%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2">11．经过修改的二叉搜索</a><br><a href="#12%EF%BC%8E%E5%89%8DK%E4%B8%AA%E5%85%83%E7%B4%A0">12．前 K 个元素</a><br><a href="#13%EF%BC%8EK%E8%B7%AF%E5%90%88%E5%B9%B6">13．K 路合并</a><br><a href="#14%EF%BC%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">14．拓扑排序</a></p>
<span id="more"></span>

<h2 id="1．滑动窗口"><a href="#1．滑动窗口" class="headerlink" title="1．滑动窗口"></a>1．滑动窗口</h2><p>滑动窗口模式是用于在给定数组或链表的特定窗口大小上执行所需的操作，比如寻找包含所有 1 的最长子数组。从第一个元素开始滑动窗口并逐个元素地向右滑，并根据你所求解的问题调整窗口的长度。在某些情况下窗口大小会保持恒定，在其它情况下窗口大小会增大或减小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    Sliding window --&gt;</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |</span><br><span class="line">+----+----+----+----+----+----+----+----+----+</span><br><span class="line">|  1 |  3 |  2 |  6 | -1 |  4 |  1 |  8 |  2 |</span><br><span class="line">+----+----+----+----+----+----+----+----+----+</span><br><span class="line">|                        |</span><br><span class="line">+------------------------+</span><br><span class="line"></span><br><span class="line">     Slide one element forward</span><br><span class="line">     +------------------------+</span><br><span class="line">     |                        |</span><br><span class="line">+----+----+----+----+----+----+----+----+----+</span><br><span class="line">|  1 |  3 |  2 |  6 | -1 |  4 |  1 |  8 |  2 |</span><br><span class="line">+----+----+----+----+----+----+----+----+----+</span><br><span class="line">     |                        |</span><br><span class="line">     +------------------------+</span><br></pre></td></tr></table></figure>

<p>下面是一些你可以用来确定给定问题可能需要滑动窗口的方法：</p>
<ul>
<li>问题的输入是一种线性数据结构，比如链表、数组或字符串</li>
<li>你被要求查找最长/最短的子字符串、子数组或所需的值</li>
</ul>
<p>可以使用滑动窗口模式处理的常见问题：</p>
<ul>
<li>大小为 K 的子数组的最大和（简单）</li>
<li>带有 K 个不同字符的最长子字符串（中等）</li>
<li>寻找字符相同但排序不一样的字符串（困难）</li>
</ul>
<h2 id="2．二指针或迭代器"><a href="#2．二指针或迭代器" class="headerlink" title="2．二指针或迭代器"></a>2．二指针或迭代器</h2><p>二指针（Two Pointers）是这样一种模式：两个指针以一前一后的模式在数据结构中迭代，直到一个或两个指针达到某种特定条件。二指针通常在排序数组或链表中搜索配对时很有用；比如当你必须将一个数组的每个元素与其它元素做比较时。</p>
<p>二指针是很有用的，因为如果只有一个指针，你必须继续在数组中循环回来才能找到答案。这种使用单个迭代器进行来回在时间和空间复杂度上都很低效——这个概念被称为「渐进分析（asymptotic analysis）」。尽管使用 1 个指针进行暴力搜索或简单普通的解决方案也有效果，但这会沿 O(n²) 线得到一些东西。在很多情况中，二指针有助于你寻找有更好空间或运行时间复杂度的解决方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                Pointer1            Pointer2</span><br><span class="line">                   |                   |</span><br><span class="line">                   V                   V</span><br><span class="line">                +----+----+----+----+----+</span><br><span class="line">target sum &#x3D; 6  |  1 |  2 |  3 |  4 |  6 |</span><br><span class="line">                +----+----+----+----+----+</span><br><span class="line"></span><br><span class="line">1 + 6 &gt; target sum, therefore let&#39;s decrement Pointer2</span><br><span class="line"></span><br><span class="line">                Pointer1       Pointer2</span><br><span class="line">                   |              |</span><br><span class="line">                   V              V</span><br><span class="line">                +----+----+----+----+----+</span><br><span class="line">                |  1 |  2 |  3 |  4 |  6 |</span><br><span class="line">                +----+----+----+----+----+</span><br><span class="line"></span><br><span class="line">1 + 4 &lt; target sum, therefore let&#39;s increment Pointer1</span><br><span class="line"></span><br><span class="line">                     Pointer1  Pointer2</span><br><span class="line">                        |         |</span><br><span class="line">                        V         V</span><br><span class="line">                +----+----+----+----+----+</span><br><span class="line">                |  1 |  2 |  3 |  4 |  6 |</span><br><span class="line">                +----+----+----+----+----+</span><br><span class="line"></span><br><span class="line">2 + 4 &#x3D;&#x3D; target sum, we have found our pair!</span><br></pre></td></tr></table></figure>
<p>用于识别使用二指针的时机的方法：</p>
<ul>
<li>可用于你要处理排序数组（或链接列表）并需要查找满足某些约束的一组元素的问题</li>
<li>数组中的元素集是配对、三元组甚至子数组</li>
</ul>
<p>下面是一些满足二指针模式的问题：</p>
<ul>
<li>求一个排序数组的平方（简单）</li>
<li>求总和为零的三元组（中等）</li>
<li>比较包含回退（backspace）的字符串（中等）</li>
</ul>
<h2 id="3．快速和慢速指针"><a href="#3．快速和慢速指针" class="headerlink" title="3．快速和慢速指针"></a>3．快速和慢速指针</h2><p>快速和慢速指针方法也被称为 Hare &amp; Tortoise 算法，该算法会使用两个在数组（或序列/链表）中以不同速度移动的指针。该方法在处理循环链表或数组时非常有用。</p>
<p>通过以不同的速度进行移动（比如在一个循环链表中），该算法证明这两个指针注定会相遇。只要这两个指针在同一个循环中，快速指针就会追赶上慢速指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">fast,slow</span><br><span class="line">  |</span><br><span class="line">  |    +----+    +----+    +----+    +----+    +----+    +----+</span><br><span class="line">  +--&gt; |  1 | -&gt; |  2 | -&gt; |  3 | -&gt; |  4 | -&gt; |  5 | -&gt; |  6 | --+</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+   |</span><br><span class="line">                              ^                                   |</span><br><span class="line">                              |                                   |</span><br><span class="line">                              +-----------------------------------+</span><br><span class="line"></span><br><span class="line">                 slow       fast</span><br><span class="line">                   |          |</span><br><span class="line">                   V          V</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+</span><br><span class="line">       |  1 | -&gt; |  2 | -&gt; |  3 | -&gt; |  4 | -&gt; |  5 | -&gt; |  6 | --+</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+   |</span><br><span class="line">                              ^                                   |</span><br><span class="line">                              |                                   |</span><br><span class="line">                              +-----------------------------------+</span><br><span class="line"></span><br><span class="line">                            slow                fast</span><br><span class="line">                              |                   |</span><br><span class="line">                              V                   V</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+</span><br><span class="line">       |  1 | -&gt; |  2 | -&gt; |  3 | -&gt; |  4 | -&gt; |  5 | -&gt; |  6 | --+</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+   |</span><br><span class="line">                              ^                                   |</span><br><span class="line">                              |                                   |</span><br><span class="line">                              +-----------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            fast       slow</span><br><span class="line">                              |         |</span><br><span class="line">                              V         V</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+</span><br><span class="line">       |  1 | -&gt; |  2 | -&gt; |  3 | -&gt; |  4 | -&gt; |  5 | -&gt; |  6 | --+</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+   |</span><br><span class="line">                              ^                                   |</span><br><span class="line">                              |                                   |</span><br><span class="line">                              +-----------------------------------+</span><br><span class="line"></span><br><span class="line">                                              fast,slow</span><br><span class="line">                                                 |</span><br><span class="line">                                                 V</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+</span><br><span class="line">       |  1 | -&gt; |  2 | -&gt; |  3 | -&gt; |  4 | -&gt; |  5 | -&gt; |  6 | --+</span><br><span class="line">       +----+    +----+    +----+    +----+    +----+    +----+   |</span><br><span class="line">                              ^                                   |</span><br><span class="line">                              |                                   |</span><br><span class="line">                              +-----------------------------------+</span><br></pre></td></tr></table></figure>
<p>如何判别使用快速和慢速模式的时机？</p>
<ul>
<li>处理链表或数组中的循环的问题</li>
<li>当你需要知道特定元素的位置或链表的总长度时</li>
</ul>
<p>何时应该优先选择这种方法，而不是上面提到的二指针方法？</p>
<ul>
<li>有些情况不适合使用二指针方法，比如在不能反向移动的单链接链表中。使用快速和慢速模式的一个案例是当你想要确定一个链表是否为回文（palindrome）时。</li>
</ul>
<p>下面是一些满足快速和慢速指针模式的问题：</p>
<ul>
<li>链表循环（简单）</li>
<li>回文链表（中等）</li>
<li>环形数组中的循环（困难）</li>
</ul>
<h2 id="4．合并区间"><a href="#4．合并区间" class="headerlink" title="4．合并区间"></a>4．合并区间</h2><p>合并区间模式是一种处理重叠区间的有效技术。在很多涉及区间的问题中，你既需要找到重叠的区间，也需要在这些区间重叠时合并它们。该模式的工作方式为：</p>
<p>给定两个区间（a 和 b），这两个区间有 6 种不同的互相关联的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">       +----------+    +------+</span><br><span class="line">1)     |    a     |    |   b  |   &#39;a&#39; and &#39;b&#39; do not overlap</span><br><span class="line">       +----------+    +------+</span><br><span class="line"></span><br><span class="line">       +----------+</span><br><span class="line">2)     |    a  +--+-----+         &#39;a&#39; and &#39;b&#39; overlap, &#39;b&#39; ends after &#39;a&#39;</span><br><span class="line">       +-------|--+     |</span><br><span class="line">               |    b   |</span><br><span class="line">               +--------+</span><br><span class="line"></span><br><span class="line">       +----------+</span><br><span class="line">3)     |    a     |</span><br><span class="line">       +-+------+-+               &#39;a&#39; completely overlap &#39;b&#39;</span><br><span class="line">         |   b  |</span><br><span class="line">         +------+</span><br><span class="line"></span><br><span class="line">            +----------+</span><br><span class="line">4)    +-----+--+   a   |          &#39;a&#39; and &#39;b&#39; overlap, &#39;a&#39; ends after &#39;b&#39;</span><br><span class="line">      |     +--+-------+</span><br><span class="line">      |   b    |</span><br><span class="line">      +--------+</span><br><span class="line"></span><br><span class="line">         +------+</span><br><span class="line">         |  a   |</span><br><span class="line">5)     +-+------+-+                &#39;b&#39; completely overlap &#39;a&#39;</span><br><span class="line">       |    b     |</span><br><span class="line">       +----------+</span><br><span class="line"></span><br><span class="line">       +----------+    +------+</span><br><span class="line">6)     |    b     |    |   a  |    &#39;b&#39; and &#39;a&#39; do not overlap</span><br><span class="line">       +----------+    +------+</span><br></pre></td></tr></table></figure>

<p>理解并识别这六种情况有助于你求解范围广泛的问题，从插入区间到优化区间合并等。</p>
<p>那么如何确定何时该使用合并区间模式呢？</p>
<ul>
<li>如果你被要求得到一个仅含互斥区间的列表</li>
<li>如果你听到了术语「重叠区间（overlapping intervals）</li>
</ul>
<p>合并区间模式的问题：</p>
<ul>
<li>区间交叉（中等）</li>
<li>最大 CPU 负载（困难）</li>
</ul>
<h2 id="5．循环排序"><a href="#5．循环排序" class="headerlink" title="5．循环排序"></a>5．循环排序</h2><p>这一模式描述了一种有趣的方法，处理的是涉及包含给定范围内数值的数组的问题。循环排序模式一次会在数组上迭代一个数值，如果所迭代的当前数值不在正确的索引处，就将其与其正确索引处的数值交换。你可以尝试替换其正确索引处的数值，但这会带来 O(n^2) 的复杂度，这不是最优的，因此要用循环排序模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">1) Number &#39;2&#39; is not at it&#39;s correct place, let&#39;s swap it with the correect index.</span><br><span class="line">      start</span><br><span class="line">        |</span><br><span class="line">        V</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">      |  2 |  6 |  4 |  3 |  1 |  5 |</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line"></span><br><span class="line">      start</span><br><span class="line">        |</span><br><span class="line">        V</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">      |  2 |  6 |  4 |  3 |  1 |  5 |</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">        ^     ^</span><br><span class="line">        |     |</span><br><span class="line">        +-----+</span><br><span class="line"></span><br><span class="line">2) After the swap, number &#39;2&#39; is placed at it&#39;s correct index.</span><br><span class="line">      start</span><br><span class="line">        |</span><br><span class="line">        V</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">      |  6 |  2 |  4 |  3 |  1 |  5 |</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line"></span><br><span class="line">3) Let&#39;s move on to the next number.</span><br><span class="line">            start</span><br><span class="line">              |</span><br><span class="line">              V</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">      |  6 |  2 |  4 |  3 |  1 |  5 |</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line"></span><br><span class="line">4) Number &#39;2&#39; is at it&#39;s correct place, Let&#39;s move on the next number.</span><br><span class="line">                 start</span><br><span class="line">                   |</span><br><span class="line">                   V</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">      |  6 |  2 |  4 |  3 |  1 |  5 |</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">                  ^     ^</span><br><span class="line">                  |     |</span><br><span class="line">                  +-----+</span><br><span class="line"></span><br><span class="line">5) Number &#39;4&#39; is not at it&#39;s corrrect place, lets swap it with the next index.</span><br><span class="line">                      start</span><br><span class="line">                        |</span><br><span class="line">                        V</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">      |  6 |  2 |  3 |  4 |  1 |  5 |</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line"></span><br><span class="line">6) Number &#39;4&#39; is at it&#39;s correct place, Let&#39;t move on to the next number.</span><br><span class="line">                          start</span><br><span class="line">                            |</span><br><span class="line">                            V</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line">      |  6 |  2 |  3 |  4 |  1 |  5 |</span><br><span class="line">      +----+----+----+----+----+----+</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如何识别这种模式？</p>
<ul>
<li>涉及数值在给定范围内的排序数组的问题</li>
<li>如果问题要求你在一个排序/旋转的数组中找到缺失值/重复值/最小值</li>
</ul>
<p>循环排序模式的问题：</p>
<ul>
<li>找到缺失值（简单）</li>
<li>找到最小的缺失的正数值（中等）</li>
</ul>
<h2 id="6．原地反转链表"><a href="#6．原地反转链表" class="headerlink" title="6．原地反转链表"></a>6．原地反转链表</h2><p>在很多问题中，你可能会被要求反转一个链表中一组节点之间的链接。通常而言，你需要原地完成这一任务，即使用已有的节点对象且不占用额外的内存。这就是这个模式的用武之地。该模式会从一个指向链表头的变量（current）开始一次反转一个节点，然后一个变量（previous）将指向已经处理过的前一个节点。以锁步的方式，在移动到下一个节点之前将其指向前一个节点，可实现对当前节点的反转。另外，也将更新变量「previous」，使其总是指向已经处理过的前一个节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    current       previous &#x3D; null</span><br><span class="line">      |</span><br><span class="line">      +-&gt; +----+    +----+    +----+    +----+    +----+    +------+</span><br><span class="line">          |  2 | -&gt; |  4 | -&gt; |  6 | -&gt; |  8 | -&gt; | 10 | -&gt; | null |</span><br><span class="line">          +----+    +----+    +----+    +----+    +----+    +------+</span><br><span class="line"></span><br><span class="line">         previous      current</span><br><span class="line">            |             |</span><br><span class="line">+------+    +-&gt; +----+    +-&gt; +----+    +----+    +----+    +----+    +------+</span><br><span class="line">| null | &lt;----- |  2 |        |  4 | -&gt; |  6 | -&gt; |  8 | -&gt; | 10 | -&gt; | null |</span><br><span class="line">+------+        +----+        +----+    +----+    +----+    +----+    +------+</span><br><span class="line"></span><br><span class="line">                   previous      current</span><br><span class="line">                      |             |</span><br><span class="line">+------+    +----+    +-&gt; +----+    +-&gt; +----+    +----+    +----+    +------+</span><br><span class="line">| null | &lt;- |  2 | &lt;----- |  4 |        |  6 | -&gt; |  8 | -&gt; | 10 | -&gt; | null |</span><br><span class="line">+------+    +----+        +----+        +----+    +----+    +----+    +------+</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何识别使用该模式的时机：</p>
<ul>
<li>如果你被要求在不使用额外内存的前提下反转一个链表</li>
</ul>
<p>原地反转链表模式的问题：</p>
<ul>
<li>反转一个子列表（中等）</li>
<li>反转每个 K 个元素的子列表（中等）</li>
</ul>
<h2 id="7．树的宽度优先搜索"><a href="#7．树的宽度优先搜索" class="headerlink" title="7．树的宽度优先搜索"></a>7．树的宽度优先搜索</h2><p>该模式基于宽度优先搜索（BFS）技术，可遍历一个树并使用一个队列来跟踪一个层级的所有节点，之后再跳转到下一个层级。任何涉及到以逐层级方式遍历树的问题都可以使用这种方法有效解决。</p>
<p>Tree BFS 模式的工作方式是：将根节点推至队列，然后连续迭代知道队列为空。在每次迭代中，我们移除队列头部的节点并「访问」该节点。在移除了队列中的每个节点之后，我们还将其所有子节点插入到队列中。</p>
<p>如何识别 Tree BFS 模式：</p>
<ul>
<li>如果你被要求以逐层级方式遍历（或按层级顺序遍历）一个树</li>
</ul>
<p>Tree BFS 模式的问题：</p>
<ul>
<li>二叉树层级顺序遍历（简单）</li>
<li>之字型遍历（Zigzag Traversal）（中等）</li>
</ul>
<h2 id="8．树的深度优先搜索"><a href="#8．树的深度优先搜索" class="headerlink" title="8．树的深度优先搜索"></a>8．树的深度优先搜索</h2><p>Tree DFS 是基于深度优先搜索（DFS）技术来遍历树。</p>
<p>你可以使用递归（或该迭代方法的技术栈）来在遍历期间保持对所有之前的（父）节点的跟踪。</p>
<p>Tree DFS 模式的工作方式是从树的根部开始，如果这个节点不是一个叶节点，则需要：</p>
<ol>
<li>决定现在是处理当前的节点（pre-order），或是在处理两个子节点之间（in-order），还是在处理两个子节点之后（post-order）</li>
<li>为当前节点的两个子节点执行两次递归调用以处理它们</li>
</ol>
<p>如何识别 Tree DFS 模式：</p>
<ul>
<li>如果你被要求用 in-order、pre-order 或 post-order DFS 来遍历一个树</li>
<li>如果问题需要搜索其中节点更接近叶节点的东西</li>
</ul>
<p>Tree DFS 模式的问题：</p>
<ul>
<li>路径数量之和（中等）</li>
<li>一个和的所有路径（中等）</li>
</ul>
<h2 id="9．TwoHeaps"><a href="#9．TwoHeaps" class="headerlink" title="9．TwoHeaps"></a>9．TwoHeaps</h2><p>在很多问题中，我们要将给定的一组元素分为两部分。为了求解这个问题，我们感兴趣的是了解一部分的最小元素以及另一部分的最大元素。这一模式是求解这类问题的一种有效方法。该模式要使用两个堆（heap）：一个用于寻找最小元素的 Min Heap 和一个用于寻找最大元素的 Max Heap。该模式的工作方式是：先将前一半的数值存储到 Max Heap，这是由于你要寻找前一半中的最大数值。然后再将另一半存储到 Min Heap，因为你要寻找第二半的最小数值。在任何时候，当前数值列表的中间值都可以根据这两个 heap 的顶部元素计算得到。</p>
<p>识别 Two Heaps 模式的方法：</p>
<ul>
<li>在优先级队列、调度等场景中有用</li>
<li>如果问题说你需要找到一个集合的最小/最大/中间元素</li>
<li>有时候可用于具有二叉树数据结构的问题</li>
</ul>
<p>Two Heaps 模式的问题：</p>
<ul>
<li>查找一个数值流的中间值（中等）</li>
</ul>
<h2 id="10．子集"><a href="#10．子集" class="headerlink" title="10．子集"></a>10．子集</h2><p>很多编程面试问题都涉及到处理给定元素集合的排列和组合。子集（Subsets）模式描述了一种用于有效处理所有这些问题的宽度优先搜索（BFS）方法。</p>
<p>该模式看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个集合 [1, 5, 3]</span><br><span class="line">1．从一个空集开始：[[]]</span><br><span class="line">2．向所有已有子集添加第一个数 (1)，从而创造新的子集：[[], [1]]</span><br><span class="line">3．向所有已有子集添加第二个数 (5)：[[], [1], [5], [1,5]]</span><br><span class="line">4．向所有已有子集添加第三个数 (3)：[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]]</span><br></pre></td></tr></table></figure>

<p>下面是这种子集模式的一种视觉表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Given set:</span><br><span class="line">      +----+----+----+</span><br><span class="line">      |  1 |  5 |  3 |</span><br><span class="line">      +----+----+----+</span><br><span class="line"></span><br><span class="line">                              +-----+</span><br><span class="line">                              | []  |</span><br><span class="line">                              +-----+</span><br><span class="line">                           copy &#x2F;  \ add 1</span><br><span class="line">                               V    V</span><br><span class="line">                           +-----+-----+</span><br><span class="line">                           | []  | [1] |</span><br><span class="line">                           +-----+-----+</span><br><span class="line">                       copy &#x2F;         \ add 5</span><br><span class="line">                           V           V</span><br><span class="line">                      +----+-----+-----+-------+</span><br><span class="line">                      | [] | [1] | [5] | [1,5] |</span><br><span class="line">                      +----+-----+-----+-------+</span><br><span class="line">                      copy &#x2F;            \ add 3</span><br><span class="line">                          V              V</span><br><span class="line">      +----+-----+-----+-------+-----+-------+-------+---------+</span><br><span class="line">      | [] | [1] | [5] | [1,5] | [3] | [1,3] | [5,3] | [1,5,3] |</span><br><span class="line">      +----+-----+-----+-------+-----+-------+-------+---------+</span><br></pre></td></tr></table></figure>
<p>如何识别子集模式：</p>
<ul>
<li>你需要找到给定集合的组合或排列的问题</li>
</ul>
<p>子集模式的问题：</p>
<ul>
<li>带有重复项的子集（简单）</li>
<li>通过改变大小写的字符串排列（中等）</li>
</ul>
<h2 id="11．经过修改的二叉搜索"><a href="#11．经过修改的二叉搜索" class="headerlink" title="11．经过修改的二叉搜索"></a>11．经过修改的二叉搜索</h2><p>只要给定了排序数组、链表或矩阵，并要求寻找一个特定元素，你可以使用的最佳算法就是二叉搜索。这一模式描述了一种用于处理所有涉及二叉搜索的问题的有效方法。</p>
<p>对于一个升序的集合，该模式看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1．首先，找到起点和终点的中间位置。寻找中间位置的一种简单方法是：middle &#x3D; (start + end) &#x2F; 2。但这很有可能造成整数溢出，所以推荐你这样表示中间位置：middle &#x3D; start + (end — start) &#x2F; 2。</span><br><span class="line">2．如果键值（key）等于中间索引处的值，那么返回这个中间位置。</span><br><span class="line">3．如果键值不等于中间索引处的值：</span><br><span class="line">4．检查 key &lt; arr[middle] 是否成立。如果成立，将搜索约简到 end &#x3D; middle — 15．检查 key &gt; arr[middle] 是否成立。如果成立，将搜索约简到 end &#x3D; middle + 1</span><br></pre></td></tr></table></figure>

<p>下面给出了这种经过修改的二叉搜索模式的视觉表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Search &#39;key&#39; &#x3D; &#39;5&#39;</span><br><span class="line"></span><br><span class="line">      start          middle          end</span><br><span class="line">        |              |              |</span><br><span class="line">        V              V              V</span><br><span class="line">      +----+----+----+----+----+----+----+</span><br><span class="line">      |  1 |  2 |  3 |  4 |  5 |  6 | 7  |</span><br><span class="line">      +----+----+----+----+----+----+----+</span><br><span class="line">As key &gt; arr[middle], therefore start &#x3D; middle + 1</span><br><span class="line"></span><br><span class="line">                         start middle end</span><br><span class="line">                            |    |     |</span><br><span class="line">                            V    V     V</span><br><span class="line">      +----+----+----+----+----+----+----+</span><br><span class="line">      |  1 |  2 |  3 |  4 |  5 |  6 | 7  |</span><br><span class="line">      +----+----+----+----+----+----+----+</span><br><span class="line">As key &lt; arr[middle], therefore end &#x3D; middle - 1</span><br><span class="line"></span><br><span class="line">                    start,middle,end</span><br><span class="line">                            |</span><br><span class="line">                            V</span><br><span class="line">      +----+----+----+----+----+----+----+</span><br><span class="line">      |  1 |  2 |  3 |  4 |  5 |  6 | 7  |</span><br><span class="line">      +----+----+----+----+----+----+----+</span><br><span class="line">As key &#x3D;&#x3D; arr[middle], return middle as the required index</span><br></pre></td></tr></table></figure>
<p>经过修改的二叉搜索模式的问题：</p>
<ul>
<li>与顺序无关的二叉搜索（简单）</li>
<li>在经过排序的无限数组中搜索（中等）</li>
</ul>
<h2 id="12．前K个元素"><a href="#12．前K个元素" class="headerlink" title="12．前K个元素"></a>12．前K个元素</h2><p>任何要求我们找到一个给定集合中前面的/最小的/最常出现的 K 的元素的问题都在这一模式的范围内。</p>
<p>跟踪 K 个元素的最佳的数据结构是 Heap。这一模式会使用 Heap 来求解多个一次性处理一个给定元素集中 K 个元素的问题。该模式是这样工作的：</p>
<p>1．根据问题的不同，将 K 个元素插入到 min-heap 或 max-heap 中<br>2．迭代处理剩余的数，如果你找到一个比 heap 中数更大的数，那么就移除那个数并插入这个更大的数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(1)   +----+----+----+----+----+----+            +----+</span><br><span class="line">      |  3 |  1 |  5 | 12 |  2 | 11 |            |  1 |</span><br><span class="line">      +----+----+----+----+----+----+            +----+</span><br><span class="line">                                                 &#x2F;     \</span><br><span class="line">                                                V       V</span><br><span class="line">      Insert the first three                 +----+   +----+</span><br><span class="line">      numbers in the heap                    |  5 |   |  3 |</span><br><span class="line">                                             +----+   +----+</span><br><span class="line"></span><br><span class="line">(2)   +----+----+----+----+----+----+            +----+</span><br><span class="line">      |  3 |  1 |  5 | 12 |  2 | 11 |            |  3 |</span><br><span class="line">      +----+----+----+----+----+----+            +----+</span><br><span class="line">                                                 &#x2F;     \</span><br><span class="line">                                                V       V</span><br><span class="line">      The root is smaller than &#39;12&#39;          +----+   +----+</span><br><span class="line">      so take &#39;1&#39; out and inset &#39;12&#39;         |  5 |   | 12 |</span><br><span class="line">                                             +----+   +----+</span><br><span class="line"></span><br><span class="line">(3)   +----+----+----+----+----+----+            +----+</span><br><span class="line">      |  3 |  1 |  5 | 12 |  2 | 11 |            |  3 |</span><br><span class="line">      +----+----+----+----+----+----+            +----+</span><br><span class="line">                                                 &#x2F;     \</span><br><span class="line">                                                V       V</span><br><span class="line">      Skip &#39;2&#39;, as it is not bigger          +----+   +----+</span><br><span class="line">      than the root &#39;3&#39;                      |  5 |   | 12 |</span><br><span class="line">                                             +----+   +----+</span><br><span class="line"></span><br><span class="line">(4)   +----+----+----+----+----+----+            +----+</span><br><span class="line">      |  3 |  1 |  5 | 12 |  2 | 11 |            |  5 |</span><br><span class="line">      +----+----+----+----+----+----+            +----+</span><br><span class="line">                                                 &#x2F;     \</span><br><span class="line">                                                V       V</span><br><span class="line">      The root is smaller than &#39;12&#39;          +----+   +----+</span><br><span class="line">      so take &#39;5&#39; out and inset &#39;12&#39;         | 11 |   | 12 |</span><br><span class="line">                                             +----+   +----+</span><br></pre></td></tr></table></figure>

<p>这里无需排序算法，因为 heap 将为你跟踪这些元素。</p>
<p>如何识别前 K 个元素模式：</p>
<ul>
<li>如果你被要求寻找一个给定集合中前面的/最小的/最常出现的 K 的元素</li>
<li>如果你被要求对一个数值进行排序以找到一个确定元素</li>
</ul>
<p>前 K 个元素模式的问题：</p>
<ul>
<li>前面的 K 个数（简单）</li>
<li>最常出现的 K 个数（中等）</li>
</ul>
<h2 id="13．K路合并"><a href="#13．K路合并" class="headerlink" title="13．K路合并"></a>13．K路合并</h2><p>K 路合并能帮助你求解涉及一组经过排序的数组的问题。</p>
<p>当你被给出了 K 个经过排序的数组时，你可以使用 Heap 来有效地执行所有数组的所有元素的排序遍历。你可以将每个数组的最小元素推送至 Min Heap 以获得整体最小值。在获得了整体最小值后，将来自同一个数组的下一个元素推送至 heap。然后，重复这一过程以得到所有元素的排序遍历结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(1)      +----+----+----+           +----+</span><br><span class="line">     L1  |-2--| 6  | 8  |           |  1 |</span><br><span class="line">         +----+----+----+           +----+</span><br><span class="line">         +----+----+----+           &#x2F;     \</span><br><span class="line">     L2  |-3--| 6  | 7  |          V       V</span><br><span class="line">         +----+----+----+        +----+   +----+</span><br><span class="line">         +----+----+----+        |  2 |   |  3 |</span><br><span class="line">     L3  |-1--| 3  | 4  |        +----+   +----+</span><br><span class="line">         +----+----+----+</span><br><span class="line">      Inset the first number from each array in the teap</span><br><span class="line"></span><br><span class="line">(2)      +----+----+----+           +----+</span><br><span class="line">     L1  |-2--| 6  | 8  |          |  2 |</span><br><span class="line">         +----+----+----+           +----+</span><br><span class="line">         +----+----+----+           &#x2F;     \</span><br><span class="line">     L2  |-3--| 6  | 7  |          V       V</span><br><span class="line">         +----+----+----+        +----+   +----+</span><br><span class="line">         +----+----+----+        |  3 |   |  3 |</span><br><span class="line">     L3  |-1--|-3--| 4  |        +----+   +----+</span><br><span class="line">         +----+----+----+</span><br><span class="line">                    +----+</span><br><span class="line">      Merged List:  | 1  |</span><br><span class="line">                    +----+</span><br><span class="line"></span><br><span class="line">(3)      +----+----+----+           +----+</span><br><span class="line">     L1  |-2--|-6--| 8  |           |  3 |</span><br><span class="line">         +----+----+----+           +----+</span><br><span class="line">         +----+----+----+           &#x2F;     \</span><br><span class="line">     L2  |-3--| 6  | 7  |          V       V</span><br><span class="line">         +----+----+----+        +----+   +----+</span><br><span class="line">         +----+----+----+        |  6 |   |  3 |</span><br><span class="line">     L3  |-1--|-3--| 4  |        +----+   +----+</span><br><span class="line">         +----+----+----+</span><br><span class="line">                    +----+----+</span><br><span class="line">      Merged List:  | 1  | 2  |</span><br><span class="line">                    +----+----+</span><br></pre></td></tr></table></figure>

<p>该模式看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1．将每个数组的第一个元素插入 Min Heap</span><br><span class="line">2．之后，从该 Heap 取出最小（顶部的）元素，将其加入到合并的列表。</span><br><span class="line">3．在从 Heap 移除了最小的元素之后，将同一列表的下一个元素插入该 Heap</span><br><span class="line">4．重复步骤 2 和 3，以排序的顺序填充合并的列表</span><br></pre></td></tr></table></figure>
<p>如何识别 K 路合并模式：</p>
<ul>
<li>具有排序数组、列表或矩阵的问题</li>
<li>如果问题要求你合并排序的列表，找到一个排序列表中的最小元素</li>
</ul>
<p>K 路合并模式的问题：</p>
<ul>
<li>合并 K 个排序的列表（中等）</li>
<li>找到和最大的 K 个配对（困难）</li>
</ul>
<h2 id="14．拓扑排序"><a href="#14．拓扑排序" class="headerlink" title="14．拓扑排序"></a>14．拓扑排序</h2><p>拓扑排序可用于寻找互相依赖的元素的线性顺序。比如，如果事件 B 依赖于事件 A，那么 A 在拓扑排序时位于 B 之前。</p>
<p>这个模式定义了一种简单方法来理解执行一组元素的拓扑排序的技术。</p>
<p>该模式看起来是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1．初始化。a）使用 HashMap 将图（graph）存储到邻接的列表中；b）为了查找所有源，使用 HashMap 记录 in-degree 的数量</span><br><span class="line">2．构建图并找到所有顶点的 in-degree。a）根据输入构建图并填充 in-degree HashMap</span><br><span class="line">3．寻找所有的源。a）所有 in-degree 为 0 的顶点都是源，并会被存入一个队列</span><br><span class="line">4．排序。</span><br><span class="line">  a）对于每个源，执行以下操作：</span><br><span class="line">      i）将其加入到排序的列表；</span><br><span class="line">      ii）根据图获取其所有子节点；</span><br><span class="line">      iii）将每个子节点的 in-degree 减少 1；</span><br><span class="line">      iv）如果一个子节点的 in-degree 变为 0，将其加入到源队列。</span><br><span class="line">  b）重复 (a)，直到源队列为空。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">                    +----+    +----+</span><br><span class="line">                    | 1  |    | 1  |</span><br><span class="line">                    +----+    +----+</span><br><span class="line">                    &#x2F;    \   &#x2F;     |</span><br><span class="line">                   V      V V      |</span><br><span class="line">              +----+     +----+    |</span><br><span class="line">              | 2  |-\   | 3  |    |</span><br><span class="line">              +----+  \  +----+    |</span><br><span class="line">              &#x2F;    \   \&#x2F;          |</span><br><span class="line">            &#x2F;       \  &#x2F;\          |</span><br><span class="line">           V        V  V \         V</span><br><span class="line">         +----+    +----+ \--&gt; +----+</span><br><span class="line">         | 2  |    | 3  |      | 3  |</span><br><span class="line">         +----+    +----+      +----+</span><br><span class="line">Add all sources to the sorted list.</span><br><span class="line">Remove all sources and their edges to find new souorces</span><br><span class="line"></span><br><span class="line">                                +----+     +----+</span><br><span class="line">                                | 2  |     | 2  |</span><br><span class="line">                                +----+     +----+</span><br><span class="line">                               &#x2F;  |   \      |</span><br><span class="line">                              V   V    V     V</span><br><span class="line">Sources: [3,4]            +----+  +----+  +----+</span><br><span class="line">Topological Sort: &quot;5,6&quot;   | 2  |  | 3  |  | 3  |</span><br><span class="line">                          +----+  +----+  +----+</span><br><span class="line"></span><br><span class="line">Add all sources to the sorted list.</span><br><span class="line">Remove all sources and their edges to find new souorces</span><br><span class="line">                          +----+  +----+  +----+</span><br><span class="line">                          | 2  |  | 3  |  | 3  |</span><br><span class="line">                          +----+  +----+  +----+</span><br><span class="line">Sources: [0,1,2]</span><br><span class="line">Topological Sort: &quot;5,6,3,4&quot;</span><br><span class="line"></span><br><span class="line">All remaining vertices are souce,</span><br><span class="line">so we will and them in the sourted list</span><br><span class="line"></span><br><span class="line">Sources: []</span><br><span class="line">Topological Sort: &quot;5,6,3,4,0,1,2&quot;</span><br></pre></td></tr></table></figure>

<p>如何识别拓扑排序模式：</p>
<ul>
<li>处理无向有环图的问题</li>
<li>如果你被要求以排序顺序更新所有对象</li>
<li>如果你有一类遵循特定顺序的对象</li>
</ul>
<p>拓扑排序模式的问题：</p>
<ul>
<li>任务调度（中等）</li>
<li>一个树的最小高度</li>
</ul>
<blockquote>
<p>参考:<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/B3hGJcqLgCyvUpTZw1nJDg">Facebook 工程师总结的 14 种算法面试模式</a></p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/02/virtualization_qemu_kvm_summary_and_api_sample_20210202/" rel="prev" title="QEMU/KVM原理概述">
      <i class="fa fa-chevron-left"></i> QEMU/KVM原理概述
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/22/virtualization_qemu_study_complex_20211022/" rel="next" title="以QEMU为例，探讨软件"基本"和"意外“的复杂性">
      以QEMU为例，探讨软件"基本"和"意外“的复杂性 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%EF%BC%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">1．滑动窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%EF%BC%8E%E4%BA%8C%E6%8C%87%E9%92%88%E6%88%96%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">2．二指针或迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%EF%BC%8E%E5%BF%AB%E9%80%9F%E5%92%8C%E6%85%A2%E9%80%9F%E6%8C%87%E9%92%88"><span class="nav-number">3.</span> <span class="nav-text">3．快速和慢速指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%EF%BC%8E%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">4.</span> <span class="nav-text">4．合并区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%EF%BC%8E%E5%BE%AA%E7%8E%AF%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">5．循环排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%EF%BC%8E%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">6．原地反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%EF%BC%8E%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">7.</span> <span class="nav-text">7．树的宽度优先搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%EF%BC%8E%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">8.</span> <span class="nav-text">8．树的深度优先搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%EF%BC%8ETwoHeaps"><span class="nav-number">9.</span> <span class="nav-text">9．TwoHeaps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%EF%BC%8E%E5%AD%90%E9%9B%86"><span class="nav-number">10.</span> <span class="nav-text">10．子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%EF%BC%8E%E7%BB%8F%E8%BF%87%E4%BF%AE%E6%94%B9%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2"><span class="nav-number">11.</span> <span class="nav-text">11．经过修改的二叉搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%EF%BC%8E%E5%89%8DK%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">12.</span> <span class="nav-text">12．前K个元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%EF%BC%8EK%E8%B7%AF%E5%90%88%E5%B9%B6"><span class="nav-number">13.</span> <span class="nav-text">13．K路合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%EF%BC%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">14.</span> <span class="nav-text">14．拓扑排序</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rayy Lee"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Rayy Lee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://beachboyy.blog.csdn.net/" title="CSDN → https:&#x2F;&#x2F;beachboyy.blog.csdn.net" rel="noopener" target="_blank"><i class="fab fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/hbuxiaofei" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;hbuxiaofei" rel="noopener" target="_blank"><i class="fab fa-fw"></i>Gitee</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rayy Lee</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '54xrQrftK3ognC5fpUdicEVY-gzGzoHsz',
      appKey     : 'jNGhKta5gAoDO4cYs1hPORoH',
      placeholder: "Add your comments",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
